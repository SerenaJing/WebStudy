<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Webstudy by SerenaJing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Webstudy</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/SerenaJing/WebStudy" class="btn">View on GitHub</a>
      <a href="https://github.com/SerenaJing/WebStudy/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/SerenaJing/WebStudy/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="冒泡排序bubble-sort" class="anchor" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>冒泡排序（Bubble Sort）</h3>

<p>最快（Best Cases）：当输入的数据已经是正序时</p>

<p>最慢（Worst Cases）：当输入的数据是反序时</p>

<pre><code>function bubbleSort(arr) {
  var len = arr.length;
  for (var i = 0; i &lt; len; i++) {
     for (var j = 0; j &lt; len - 1 - i; j++) {
         if (arr[j] &gt; arr[j+1]) {        //相邻元素两两对比
             var temp = arr[j+1];        //元素交换
             arr[j__+1] = arr[j];
             arr[j] = temp;
         }
     }
   }
 return arr;
 }
</code></pre>

<h3>
<a id="选择排序selection-sort" class="anchor" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselection-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>选择排序（Selection Sort）</h3>

<p>在时间复杂度上最稳定，无论何时都是O(n²)的时间复杂度，所以数据规模越小越好。好处是不占用额外的内存空间。</p>

<pre><code>function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     //寻找最小的数
                minIndex = j;                 //将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
</code></pre>

<h3>
<a id="插入排序insertion-sort" class="anchor" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8Finsertion-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>插入排序（Insertion Sort）</h3>

<pre><code>function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
</code></pre>

<h3>
<a id="归并排序merge-sort" class="anchor" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>归并排序（Merge Sort）</h3>

<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好，因为时间复杂度始终是O(nlogn）。代价是需要额外的内存空间。</p>

<pre><code>function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;
    if(len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
function merge(left, right)
{
    var result = [];
    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
    while (left.length)
        result.push(left.shift());
    while (right.length)
        result.push(right.shift());
    return result;
}
</code></pre>

<h3>
<a id="快速排序quick-sort" class="anchor" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fquick-sort" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>快速排序（Quick Sort）</h3>

<p>快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(nlogn) ，且O(nlogn)记号中隐含的常数因子很小，比复杂度稳定等于O(nlogn)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>

<pre><code>function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;
    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
function partition(arr, left ,right) {     //分区操作
    var pivot = left,                      //设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }        
    }
    swap(arr, pivot, index - 1);
    return index-1;
}
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre>

<hr>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/SerenaJing/WebStudy">Webstudy</a> is maintained by <a href="https://github.com/SerenaJing">SerenaJing</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
