{
  "name": "Webstudy",
  "tagline": "",
  "body": "### 冒泡排序（Bubble Sort）\r\n  最快（Best Cases）：当输入的数据已经是正序时\r\n  \r\n  最慢（Worst Cases）：当输入的数据是反序时\r\n\r\n    function bubbleSort(arr) {\r\n      var len = arr.length;\r\n      for (var i = 0; i < len; i++) {\r\n         for (var j = 0; j < len - 1 - i; j++) {\r\n             if (arr[j] > arr[j+1]) {        //相邻元素两两对比\r\n                 var temp = arr[j+1];        //元素交换\r\n                 arr[j__+1] = arr[j];\r\n                 arr[j] = temp;\r\n             }\r\n         }\r\n       }\r\n     return arr;\r\n     }\r\n\r\n### 选择排序（Selection Sort）\r\n  在时间复杂度上最稳定，无论何时都是O(n²)的时间复杂度，所以数据规模越小越好。好处是不占用额外的内存空间。\r\n\r\n    function selectionSort(arr) {\r\n        var len = arr.length;\r\n        var minIndex, temp;\r\n        for (var i = 0; i < len - 1; i++) {\r\n            minIndex = i;\r\n            for (var j = i + 1; j < len; j++) {\r\n                if (arr[j] < arr[minIndex]) {     //寻找最小的数\r\n                    minIndex = j;                 //将最小数的索引保存\r\n                }\r\n            }\r\n            temp = arr[i];\r\n            arr[i] = arr[minIndex];\r\n            arr[minIndex] = temp;\r\n        }\r\n        return arr;\r\n    }\r\n\r\n### 插入排序（Insertion Sort）\r\n    function insertionSort(arr) {\r\n        var len = arr.length;\r\n        var preIndex, current;\r\n        for (var i = 1; i < len; i++) {\r\n            preIndex = i - 1;\r\n            current = arr[i];\r\n            while(preIndex >= 0 && arr[preIndex] > current) {\r\n                arr[preIndex+1] = arr[preIndex];\r\n                preIndex--;\r\n            }\r\n            arr[preIndex+1] = current;\r\n        }\r\n        return arr;\r\n    }\r\n\r\n### 归并排序（Merge Sort）\r\n  和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好，因为时间复杂度始终是O(nlogn）。代价是需要额外的内存空间。\r\n\r\n    function mergeSort(arr) {  //采用自上而下的递归方法\r\n        var len = arr.length;\r\n        if(len < 2) {\r\n            return arr;\r\n        }\r\n        var middle = Math.floor(len / 2),\r\n            left = arr.slice(0, middle),\r\n            right = arr.slice(middle);\r\n        return merge(mergeSort(left), mergeSort(right));\r\n    }\r\n    function merge(left, right)\r\n    {\r\n        var result = [];\r\n        while (left.length && right.length) {\r\n            if (left[0] <= right[0]) {\r\n                result.push(left.shift());\r\n            } else {\r\n                result.push(right.shift());\r\n            }\r\n        }\r\n        while (left.length)\r\n            result.push(left.shift());\r\n        while (right.length)\r\n            result.push(right.shift());\r\n        return result;\r\n    }\r\n\r\n### 快速排序（Quick Sort）\r\n  快速排序的最坏运行情况是O(n²)，比如说顺序数列的快排。但它的平摊期望时间是O(nlogn) ，且O(nlogn)记号中隐含的常数因子很小，比复杂度稳定等于O(nlogn)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。\r\n\r\n    function quickSort(arr, left, right) {\r\n        var len = arr.length,\r\n            partitionIndex,\r\n            left = typeof left != 'number' ? 0 : left,\r\n            right = typeof right != 'number' ? len - 1 : right;\r\n        if (left < right) {\r\n            partitionIndex = partition(arr, left, right);\r\n            quickSort(arr, left, partitionIndex-1);\r\n            quickSort(arr, partitionIndex+1, right);\r\n        }\r\n        return arr;\r\n    }\r\n    function partition(arr, left ,right) {     //分区操作\r\n        var pivot = left,                      //设定基准值（pivot）\r\n            index = pivot + 1;\r\n        for (var i = index; i <= right; i++) {\r\n            if (arr[i] < arr[pivot]) {\r\n                swap(arr, i, index);\r\n                index++;\r\n            }        \r\n        }\r\n        swap(arr, pivot, index - 1);\r\n        return index-1;\r\n    }\r\n    function swap(arr, i, j) {\r\n        var temp = arr[i];\r\n        arr[i] = arr[j];\r\n        arr[j] = temp;\r\n    }\r\n\r\n***\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}